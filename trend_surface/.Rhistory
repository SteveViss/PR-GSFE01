test <- sp.kde(x= hml_avg_tp,
y = hml_avg_tp$avg_tp,
bw = 1000,
newdata = r_ref,
standardize = TRUE,
scale.factor = 10000)
plot(test)
plot(test)
test
plot9meuse.grid
plot(meuse.grid)
data(meuse.grid)
plot(meuse.grid)
coordinates(meuse.grid) = ~x+y
proj4string(meuse.grid) <- CRS("+init=epsg:28992")
gridded(meuse.grid) = TRUE
meuse.grid <- raster(meuse.grid)
plot(meuse.grid)
r_ref
length(r_ref)
r_ref[1:length(r_ref)]<- 0
test <- sp.kde(x= hml_avg_tp,
y = hml_avg_tp$avg_tp,
bw = 1000,
newdata = r_ref,
standardize = TRUE,
scale.factor = 10000)
r_ref[1:length(r_ref)]<- 0
test <- sp.kde(x= hml_avg_tp,
y = hml_avg_tp$avg_tp,
bw = 1000,
newdata = r_ref,
standardize = TRUE,
scale.factor = 10000)
plot(test)
# Clean results for projection
wgk_mask <- mask(wgk, lake)
# Weighted gaussian kernel
wgk <- sp.kde(x= hml_avg_tp,
y = hml_avg_tp$avg_tp,
bw = 1000,
newdata = r_ref,
standardize = TRUE,
scale.factor = 10000)
# Clean results for projection
wgk_mask <- mask(wgk, lake)
# Draw map
mapview(wgk_mask)
# Weighted gaussian kernel
wgk <- sp.kde(x= hml_avg_tp,
y = hml_avg_tp$avg_tp,
bw = 1000,
newdata = r_ref,
standardize = TRUE,
scale.factor = 10000)
# Clean results for projection
wgk_mask <- mask(wgk, lake)
# Draw map
mapview(wgk_mask)
# Draw map
mapview(wgk_mask)
library(sf)
# The RDS file is an R object and can be read with the following command:
hamilton_habitat_desc <- readRDS("../data/post_process/hamilton_habitat.rds")
lake <- st_read("../data/raw/hamilton_harbor.gdb", layer="waterbody_2")
# Making sure both are on the same CRS
st_crs(lake) == st_crs(hamilton_habitat_desc)
hamilton_habitat_desc <- st_transform(hamilton_habitat_desc, st_crs(lake))
# Because, the data contains replicates (several years and samples), we want to average all measurements of
# total phosphorus by site.
library(dplyr)
hamilton_tp <- hamilton_habitat_desc %>%
filter(Variable == "TP") %>%
group_by(Site.Site)
mapview(hamilton_avg_tp, zcol='avg_tp', cex = 'avg_tp' )
mapview(hamilton_avg_tp, zcol='tp', cex = 'tp' )
mapview(hamilton_tp, zcol='tp', cex = 'tp' )
hamilton_tp <- hamilton_habitat_desc %>%
filter(Variable == "TP") %>%
group_by(Site.Site)
mapview(hamilton_tp, zcol='tp', cex = 'tp' )
hamilton_tp
mapview(hamilton_tp)
mapview(hamilton_tp, zcol='tp', cex = 'tp_avg' )
mapview(hamilton_tp, zcol='tp_avg', cex = 'tp_avg' )
mapview(hamilton_tp, zcol='tp_avg', cex = 'tp_avg' )
mapview(hamilton_tp, zcol='Year.Année', cex = 'Year.Année' )
mapview(hamilton_tp, zcol='Year.Année')
hml_avg_tp <- as(hamilton_avg_tp, "Spatial")
lake <- as(lake, "Spatial")
library(raster)
library(gstat)
gs <- gstat(formula=avg_tp~1, locations=hml_avg_tp)
gs_5 <- gstat(formula=avg_tp~1, locations=hml_avg_tp, set = list(idp = 5))
hml_tp <- as(hamilton_tp, "Spatial")
lake <- as(lake, "Spatial")
plot(lake)
plot(lake)
hml_tp <- as(hamilton_tp, "Spatial")
lake <- as(lake, "Spatial")
plot(lake)
lake
plot(hml_tp)
lakes
lake <- st_read("../data/raw/hamilton_harbor.gdb", layer="waterbody_2")
# Making sure both are on the same CRS
st_crs(lake) == st_crs(hamilton_habitat_desc)
hamilton_habitat_desc <- st_transform(hamilton_habitat_desc, st_crs(lake))
lake <- as(lake, "Spatial")
lake
plot(lake)
hamilton_habitat_desc$VariableDescription
unique(hamilton_habitat_desc$VariableDescription)
unique(hamilton_habitat_desc$Variable)
# Total Phosphorus in sediment
hamilton_tp <- hamilton_habitat_desc %>%
filter(Variable == "TP") %>%
group_by(Site.Site)
# Lake Bottom Temperature
hamilton_lbt <- hamilton_habitat_desc %>%
filter(Variable == "General-TempLakeBottom") %>%
group_by(Site.Site)
# Depth from Surface
hamilton_depth <- hamilton_habitat_desc %>%
filter(Variable == "Depth-Lake") %>%
group_by(Site.Site)
mapview(hamilton_tp, zcol='Year.Année')
mapview(hamilton_lbt, zcol='Year.Année')
mapview(hamilton_depth, zcol='Year.Année')
mapview(hamilton_tp, zcol='Year.Année', cex = "Value.Valeur")
mapview(hamilton_lbt, zcol='Year.Année', cex = "Value.Valeur")
mapview(hamilton_depth, zcol='Year.Année', cex = "Value.Valeur")
hml_tp <- as(hamilton_tp, "Spatial")
hml_depth <- as(hamilton_depth, "Spatial")
hml_lbt <- as(hamilton_lbt, "Spatial")
lake <- as(lake, "Spatial")
plot(lake)
res <- lm(hml_tp$Value.Valeur ~ hml_lbt$Value.Valeur + hml_depth$Value.Valeur)
summary(lmTp)
lmTp <- lm(hml_tp$Value.Valeur ~ hml_lbt$Value.Valeur + hml_depth$Value.Valeur)
summary(lmTp)
?krige
lmKrigeTp <- krige(hml_tp$Value.Valeur ~ hml_lbt$Value.Valeur + hml_depth$Value.Valeur, newdata = r_ref)
library(raster)
library(gstat)
lmKrigeTp <- krige(hml_tp$Value.Valeur ~ hml_lbt$Value.Valeur + hml_depth$Value.Valeur, newdata = r_ref)
hml_tp
# Because, the data contains replicates (several years and samples), we want to average all measurements of
# total phosphorus by site.
library(dplyr)
# Total Phosphorus in sediment
hamilton_tp <- hamilton_habitat_desc %>%
filter(Variable == "TP") %>%
group_by(Site.Site) %>%
summarise(avg_tp=mean(Value.Valeur))
# Lake Bottom Temperature
hamilton_lbt <- hamilton_habitat_desc %>%
filter(Variable == "General-TempLakeBottom") %>%
group_by(Site.Site) %>%
summarise(avg_tp=mean(Value.Valeur))
# Depth from Surface
hamilton_depth <- hamilton_habitat_desc %>%
filter(Variable == "Depth-Lake") %>%
group_by(Site.Site) %>%
summarise(avg_tp=mean(Value.Valeur))
mapview(hamilton_tp, zcol='Year.Année', cex = "Value.Valeur")
mapview(hamilton_lbt, zcol='Year.Année', cex = "Value.Valeur")
# Because, the data contains replicates (several years and samples), we want to average all measurements of
# total phosphorus by site.
library(dplyr)
# Total Phosphorus in sediment
hamilton_tp <- hamilton_habitat_desc %>%
filter(Variable == "TP") %>%
group_by(Site.Site)
# Lake Bottom Temperature
hamilton_lbt <- hamilton_habitat_desc %>%
filter(Variable == "General-TempLakeBottom") %>%
group_by(Site.Site)
# Depth from Surface
hamilton_depth <- hamilton_habitat_desc %>%
filter(Variable == "Depth-Lake") %>%
group_by(Site.Site)
mapview(hamilton_tp, zcol='Year.Année', cex = "Value.Valeur")
mapview(hamilton_lbt, zcol='Year.Année', cex = "Value.Valeur")
lake <- as(lake, "Spatial")
hml$depth <- hml_depth$Value.Valeur
hml <- hml_tp
hml$depth <- hml_depth$Value.Valeur
hml$lbt <- lbt$Value.Valeur
hml$lbt <- hml_lbt$Value.Valeur
colnames(hml@data)
colnames(hml@data)[17] <- "tp"
lmTp <- lm(tp ~ lbt + depth, data = hml@sata)
hml@data
lmTp <- lm(tp ~ lbt + depth, data = hml@data)
summary(lmTp)
lmKrigeTp <- krige(tp ~ lbt + depth, data = hml, newdata = r_ref)
lmKrigeTp <- krige(tp ~ lbt, data = hml, newdata = r_ref)
hml
idw
?gstat
?interpolate
idwSE <- interpolate(r_ref, gs, fun = predict.se)
plot(idwSE)
idwSE <- interpolate(r_ref, gs, fun = predict)
plot(idwSE)
lmKrigeTp <- krige(tp ~ lbt, data = hml, newdata = r_ref)
r_ref[1:length(r_ref)] <- 0
lmKrigeTp <- krige(tp ~ lbt, data = hml, newdata = r_ref)
hmlDF <- hml@data
mhlDF$y <- coordinates(hml)[,2]
# A data.frame of the non-spatial data
hmlDF <- hml@data
hmlDF$x <- coordinates(hml)[,1]
hmlDF$y <- coordinates(hml)[,2]
lmTp <- lm(tp ~ poly(x,y,3), data = hmlDF)
lmTp <- lm(tp ~ poly(x,y,3), data = hmlDF)
tp
hmlDF$tp
hmlDF$x
hmlDF$y
lmTp <- lm(tp ~ poly(scale(x),scale(y),3), data = hmlDF)
lmTp <- lm(tp ~ x+ y, data = hmlDF)
lmTp <- lm(tp ~ x + y + I(x^2) + I(y^2) + I(x*y), data = hmlDF)
summary(lmTp)
hmlDF$x
hmlDF$x^2
# A data.frame of the non-spatial data
hmlDF <- hml@data
hmlDF$x <- scale(coordinates(hml)[,1])
hmlDF$y <- scale(coordinates(hml)[,2])
lmTp <- lm(tp ~ x + y + I(x^2) + I(y^2) + I(x*y), data = hmlDF)
summary(lmTp)
?krige
lmKrigeTp <- krige(tp ~ lbt, data = hml, newdata = r_ref)
lmKrigeTp <- krige(tp ~ lbt,, location = hml, newdata = r_ref)
lmKrigeTp <- krige(tp ~ lbt,, location = hml, data = r_ref)
lmKrigeTp <- krige(tp ~ lbt,location = hml, data = r_ref)
lmKrigeTp <- krige(tp ~ lbt,location = hml, newdata = r_ref)
plot(r_ref)
lmKrigeTp <- krige(tp ~ lbt, location = hml, newdata = r_ref)
lmKrigeTp <- krige(tp ~ lbt, data = hml, newdata = r_ref)
lmKrigeTp <- krige(tp ~ lbt, location = hml, newdata = r_ref)
?krige
?gstat
lmKrigeTp <- gstat(tp ~ lbt, location = hml, newdata = r_ref)
lmKrigeTp <- gstat(tp ~ lbt, location = hml)
lmKrigeTp <- gstat(formula = tp ~ lbt, location = hml)
interpolate(object = r_ref, model = lmKrigeTp)
lmKrigeTp <- gstat(formula = tp ~ lbt, location = hml)
interpolate(object = r_ref, model = lmKrigeTp)
hml
hml$lbt
lmKrigeTp <- gstat(formula = tp ~ 1, location = hml)
interpolate(object = r_ref, model = lmKrigeTp)
interpolate(object = r_ref, model = lmKrigeTp, fun = predict)
lmMap <- interpolate(object = r_ref, model = lmKrigeTp, fun = predict)
lmGstatTp <- gstat(formula = tp ~ lbt, data = hml)
lmMap <- interpolate(object = r_ref, model = lmKrigeTp, fun = predict)
lmGstatTp <- gstat(formula = tp ~ 1, degree = 2, data = hml)
lmMap <- interpolate(object = r_ref, model = lmKrigeTp, fun = predict)
lmGstatTp <- gstat(formula = tp ~ 1, degree = 2, data = hml)
lmMapSE <- interpolate(object = r_ref, model = lmKrigeTp, fun = predict.se)
plot(lmMapSE)
plot(lmMap)
lmMapSE <- interpolate(object = r_ref, model = lmKrigeTp, fun = "predict.se")
plot(lmMapSE)
r_ref
coordinates(r_ref)
head(coordinates(r_ref))
r_ref$layer<-predict(lmTP, newdata = coordinates(r_ref))
lmTp <- lm(tp ~ x + y + I(x^2) + I(y^2) + I(x*y), data = hmlDF)
r_ref$layer<-predict(lmTP, newdata = coordinates(r_ref))
?predict
?predict.lm
predict(lmTP, newdata = coordinates(r_ref))
class(coordinates(r_ref))
r_ref$layer<-predict(lmTP, newdata = as.data.frame(coordinates(r_ref)))
lmTp <- lm(tp ~ x + y + I(x^2) + I(y^2) + I(x*y), data = hmlDF)
xyPred <- as.data.frame(coordinates(r_ref))
predict(lmTP, newdata = xyPred)
predict(lmTp, newdata = xyPred)
colnames(xyPred)
predict(lmTp, newdata = xyPred)
# A data.frame of the non-spatial data
hmlDF <- hml@data
hmlDF$x <-coordinates(hml)[,1]
hmlDF$y <- coordinates(hml)[,2]
lmTp <- lm(tp ~ x + y + I(x^2) + I(y^2) + I(x*y), data = hmlDF)
xyPred <- as.data.frame(coordinates(r_ref))
r_ref$layer<-predict(lmTp, newdata = xyPred)
predict(lmTp, newdata = xyPred)
r_ref[1:length(r_ref)]<-predict(lmTp, newdata = xyPred)
r_ref
plot(r_ref)
mask(lake, r_ref)
mask(r_ref, lake)
rTrend <- r_ref
rTrend[1:length(r_ref)]<-predict(lmTp, newdata = xyPred)
lmTp <- lm(tp ~ x + y, data = hmlDF)
xyPred <- as.data.frame(coordinates(r_ref))
rTrend <- r_ref
rTrend[1:length(r_ref)]<-predict(lmTp, newdata = xyPred)
rTrendMask <- mask(rTrend, lake)
lake
lake <- st_read("../data/raw/hamilton_harbor.gdb", layer="waterbody_2")
# Making sure both are on the same CRS
st_crs(lake) == st_crs(hamilton_habitat_desc)
hamilton_habitat_desc <- st_transform(hamilton_habitat_desc, st_crs(lake))
# SpatialPolygons
lake <- as(lake, "Spatial")
rTrendMask <- mask(rTrend, lake)
plot(rTrendMask)
lmGstatTp <- gstat(formula = tp ~ 1, degree = 2, location = hml)
lmMapSE <- interpolate(object = r_ref, model = lmKrigeTp, fun = "predict.se")
plot(lmMapSE)
lmGstatTp <- gstat(formula = tp ~ 1, degree = 4, location = hml)
lmMapSE <- interpolate(object = r_ref, model = lmKrigeTp, fun = "predict.se")
plot(lmMapSE)
?gstat
install_github("andrewzm/STRbook")
library(devtools)
install_github("andrewzm/STRbook")
library(STRbook)
?STRbook
??STRbook
print(STRbook)
str(STRbook)
data("NOAA_df_1990")
plot9NOAA_df_1990
plot(NOAA_df_1990)
NOAA_df_1990
class(NOAA_df_1990)
dim(NOAA_df_1990)
lmTp <- lm(tp ~ lbt, data = hmlDF)
lmTp <- lm(tp ~ lbt + I(lbt^2), data = hmlDF)
lmTp <- lm(tp ~ lbt + I(lbt^2) + I(lbt^3), data = hmlDF)
lmTp <- lm(tp ~ lbt + I(lbt^2) + I(lbt^3), data = hmlDF)
hml$depth
?extract
extract(r_refl,hml)
extract(r_ref,hml)
?rasterize
rasterize(hml, r_ref)
rasterize(hml, r_ref, fun = "count")
hml[[1]]
hmlRaster <- rasterize(hml, r_ref, fun = "count")
plot(hmlRaster[1])
plot(hmlRaster[[1]])
which(!is.na(hmlRaster[[1]]))
!is.na(hmlRaster[[1]]@data)
(hmlRaster[[1]]@data)
(!is.na(hmlRaster[[1]]@data))
(hmlRaster[[1]]@data)
!is.na(value(hmlRaster)[,1])
(!is.na(values(hmlRaster)[,1]))
which(!is.na(values(hmlRaster)[,1]))
xy <-scale(coordinates(r_ref))
xySample <- xy[sampleLoc,]
sampleLoc <- which(!is.na(values(hmlRaster)[,1]))
xy <-scale(coordinates(r_ref))
xySample <- xy[sampleLoc,]
# Add x and y to hmlDF
hmlDF$x <- xySample[,1]
hmlDF$y <- xySample[,2]
# Add x and y to hmlDF
hmlDF$x <- xySample[,1]
sampleLoc
hmlRaster <- rasterize(hml, r_ref, fun = "length")
?extract
?xyFromCell
sampleLoc <- cellFromXY(r_ref, hml)
sampleLoc
xy <-scale(coordinates(r_ref))
xySample <- xy[sampleLoc,]
# Add x and y to hmlDF
hmlDF$x <- xySample[,1]
hmlDF$y <- xySample[,2]
lmTp <- lm(tp ~ poly(x, y, 3), data = hmlDF)
xyPred <- as.data.frame(coordinates(r_ref))
rTrend[1:length(r_ref)]<-predict(lmTp, newdata = xy)
predict(lmTp, newdata = xy)
hmlDF
class(xy)
head(xy)
rTrend[1:length(r_ref)]<-predict(lmTp, newdata = as.data.frame(xy))
lmTp <- lm(tp ~ poly(x, y, 3), data = hmlDF)
rTrend <- r_ref
lmTp <- lm(tp ~ poly(x, y, 3), data = hmlDF)
poly(x, y, 3)
hmlDF
hmlDF$tp
hmlDF$x
hmlDF$Type.Type
hmlDF$y
rTrend[1:length(r_ref)]
r_ref <- raster(lake,res=100)
rTrend <- r_ref
rTrend[1:length(r_ref)]<-predict(lmTp, newdata = as.data.frame(xy))
predict(lmTp, newdata = as.data.frame(xy))
# A data.frame of the non-spatial data
hmlDF <- hml@data$tp
# Add x and y to hmlDF
hmlDF$x <- xySample[,1]
# A data.frame of the non-spatial data
tp <- hml@data$tp
# Add x and y to hmlDF
hmlDF <- data.frame(tp = tp, x = xySample[,1], y = xySample[,2])
lmTp <- lm(tp ~ poly(x, y, 3), data = hmlDF)
head(hmlDF)
poly(x, y, 3)
lmTp <- lm(tp ~ x + y + I(x^2) + I(y^2) + I(x*y), data = hmlDF)
rTrend <- r_ref
rTrend[1:length(r_ref)]<-predict(lmTp, newdata = as.data.frame(xy))
summary(lmTp)
length(r_ref)
dim(as.data.frame(xy))
predict(lmTp, newdata = as.data.frame(xy))
rTrend[1:length(rTrend)]<-predict(lmTp, newdata = as.data.frame(xy))
rTrendMask <- mask(rTrend, lake)
plot(rTrendMask)
amTp <- gam(tp ~ s(x,y), data = hmlDF)
library(mgcv)
amTp <- gam(tp ~ s(x,y), data = hmlDF)
amTp <- gam(tp ~ s(x,y), data = hmlDF, family = "gaussian")
summary(amTp)
rAMTrend <- r_ref
rAMTrend[1:length(rAMTrend)]<-predict(amTp, newdata = as.data.frame(xy))
rAMTrend <- r_ref
rAMTrend[1:length(rAMTrend)]<-predict(amTp, newdata = as.data.frame(xy))
rAMTrendMask <- mask(rAMTrend, lake)
plot(rAMTrendMask)
summary(lmTp)
RSS <- sum((hmlDF$tp - predict(lmTp))^2)
RSS
lmTp
coef(lmTp)
length(coef(lmTp))
m <- nrow(hmlDF)
ncoef <- length(coef(lmTp))
varResid <- RSS/(m - ncoef)
varResid
ncoef <- length(coef(amTp))
ncoef
m <- nrow(hmlDF)
m <- nrow(hmlDF)
ncoef <- length(coef(lmTp))
varResidLM <- RSSLM/(m - ncoef)
RSSLM <- sum((hmlDF$tp - predict(lmTp))^2)
m <- nrow(hmlDF)
ncoef <- length(coef(lmTp))
varResidLM <- RSSLM/(m - ncoef)
varResidLM
RSSAM <- sum((hmlDF$tp - predict(AMTp))^2)
library(mgcv)
AMTp <- gam(tp ~ s(x,y), data = hmlDF, family = "gaussian")
summary(amTp)
rAMTrend <- r_ref
rAMTrend[1:length(rAMTrend)]<-predict(amTp, newdata = as.data.frame(xy))
rAMTrendMask <- mask(rAMTrend, lake)
plot(rAMTrendMask)
RSSAM <- sum((hmlDF$tp - predict(AMTp))^2)
m <- nrow(hmlDF)
ncoef <- length(coef(amTp))
varResidAM <- RSSAM/(m - ncoef)
varResidAM
??"Moran's I"
library(spdep)
library(spdep)
?moran
# Construct neigbours
dnearneigh(coordinates(hml), 0, 10)
plot(dnn, coordinates(hml))
# Construct neigbours
dnn <- dnearneigh(coordinates(hml), 0, 10)
plot(dnn, coordinates(hml))
# Construct neigbours
dnn <- dnearneigh(coordinates(hml), 0, 100)
plot(dnn, coordinates(hml))
# Construct neigbours
dnn <- dnearneigh(coordinates(hml), 0, 1000)
plot(dnn, coordinates(hml))
# Construct neigbours
dnn <- dnearneigh(coordinates(hml), 0, 500)
plot(dnn, coordinates(hml))
moran(tp, dnn)
?moran.text
?moran.test
class(dnn)
moran.test(tp, nb2list(dnn))
moran.test(tp, nb2listw(dnn))
# Construct neigbours
dnn <- dnearneigh(coordinates(hml), 0, 1000)
plot(dnn, coordinates(hml))
moran.test(tp, nb2listw(dnn))
# Construct neigbours
dnn <- dnearneigh(coordinates(hml), 0, 1500)
plot(dnn, coordinates(hml))
moran.test(tp, nb2listw(dnn))
MoranI <- moran.test(tp, nb2listw(dnn))
MoranI
MoranI <- moran.test(tp, nb2listw(dnn), alternative = "two.sided")
MoranI
MoranI <- moran.mc(tp, nb2listw(dnn), nsim = 999,  alternative = "two.sided", zero.policy = TRUE)
MoranI <- moran.mc(tp, nb2listw(dnn), nsim = 999,  alternative = "greater", zero.policy = TRUE)
MoranI
# Construct neigbours
dnn <- dnearneigh(coordinates(hml), 0, 100)
plot(dnn, coordinates(hml))
MoranI <- moran.mc(tp, nb2listw(dnn), nsim = 999,  alternative = "greater", zero.policy = TRUE)
MoranI <- moran.mc(tp, nb2listw(dnn), nsim = 999,  alternative = "greater", zero.policy = FALSE)
MoranI <- moran.mc(tp, nb2listw(dnn), nsim = 999,  alternative = "greater", zero.policy = NULL)
