---
title: "GSFE01"
author: "Guillaume Blanchet & Steve Vissault"
date: "2018/02/16"
output:
  xaringan::moon_reader:
    css: [default, pr.css, pr-fonts.css, "hygge"]
    lib_dir: assets
    seal: false
    nature:
      highlightStyle: monokai
      highlightLines: true
      countIncrementalSlides: false
      beforeInit: "macros.js"
---

class: title-slide, middle

<img src="assets/img/pr.png" width="80px" style="padding-right:10px; border-right: 2px solid #FAFAFA;"></img>
<img src="assets/img/UdeS_blanc.png" width="350px" ></img>

# Variogram

.instructors[
  GSFE01 - F. Guillaume Blanchet & Steve Vissault
]


---


```{r setup, include=FALSE}
options(htmltools.dir.version = FALSE)

library(sp)
library(gstat)
library(sf)

# Load data
hamilton <- readRDS("../data/post_process/hamilton_habitat.rds")
ham <- st_transform(hamilton, crs = 3161)
```

# Generalities about variograms

## Definition

.content-box-green[**Variogram**

A variogram displays the variance of a variable measured at two different location in space.]

.content-box-green[**Covariogram**

A covariogram displays the variance of a variable measured at two different location in space across time.]

---

# Variogram or semivariogram?

In the litterature there are confusions about how to call a variogram.

Some call it a **variogram** while other call it a **semivariogram**.

The reason why **semivariogram** (or semivariance) is sometimes used stem from the fact that what is represented when plotting a variogram is *half* the variance.

Bachmaier and Backes (2008) discussed this confusion and they showed that the term **variogram** should be used and that the terms *semivariance* and *semivariogram* should be avoided.

---

# Types of variogram

We will see different types of (co)variogram today

## Spatial variogram
- Cloud variogram
- Empirical variogram (sometimes referred to as *sample variogram*)
- Model variogram
- Directional variogram

## Spatiotemporal variogram
- Empirical variogram
- Model variogram

---
class: inverse, center, middle


# Spatial variogram

<html><div style='float:left'></div><hr color='#EB811B' size=3px width=720px></html> 
<html><div style='float:left'></div><hr color='#EB811B' size=3px width=720px></html> 

---
class: inverse, center, middle

# Cloud variogram

<html><div style='float:left'></div><hr color='#EB811B' size=1px width=720px></html> 

---
# Definition

.content-box-green[.small[A **cloud variogram** displays the variance between all pairs of samples for a variable]]

## Mathematical definition

$$\begin{align}
2\gamma(\mathbf{s}_1, \mathbf{s}_2) =\gamma(\mathbf{h})=& \text{var}\left(Z(\mathbf{s}_1) - Z(\mathbf{s}_2)\right)\\
=& \text{var}\left(Z(\mathbf{s} + \mathbf{h}) - Z(\mathbf{s})\right)
\end{align}$$

So
$$\begin{align}
\gamma(\mathbf{h})= \frac{\text{var}\left(Z(\mathbf{s} + \mathbf{h}) - Z(\mathbf{s})\right)}{2}
\end{align}$$
where
.small[
- $\mathbf{s_1}$ : Location of sample 1
- $\mathbf{s_2}$ : Location of sample 2
- $Z(\mathbf{s_1})$ : Value of variable sampled at sample 1
- $Z(\mathbf{s_2})$ : Value of variable sampled at sample 2
- $\mathbf{h}$ : Distance between sample 1 and sample 2
]

---
# Visualization of the cloud variogram
```{r,echo = FALSE, fig.height=5, fig.width=12, eval=TRUE, fig.retina =2}
# Focus on 2005
ham2005 <- ham[which(ham$Year.Année == 2005),]

# Select TP
tp <- ham2005[ham2005$Variable == "TP",]
tpSP <- as(tp, "Spatial")

maxDist <- max(dist(coordinates(tpSP)))
varioCloud <- variogram(Value.Valeur ~ 1,
                   data = tpSP,
                   cloud= TRUE,
                   cutoff = maxDist)

par(mar = c(5,6.5,0.5,0.5))
plot(varioCloud$dist, varioCloud$gamma,
     xlab = "Distance (m)",
     ylab = "",
     cex.lab = 2, las = 1)
mtext(text = "Variance",side = 2, cex = 2, line = 4)
```

## Use of cloud variogram
- Exploratory analysis
- It is the basis to construct the empirical variogram

---

# Directional variogram

The variogram in the previous slide is constructed using all samples equally. 

This does not have to be the case. We can also construct a variogram using only samples in a cone in specific direction. These variograms are known as **directional variograms** 

```{r,echo = FALSE, fig.height=5, fig.width=12, eval=TRUE}
varioCloud <- variogram(Value.Valeur ~ 1,
                   data = tpSP,
                   cloud= TRUE,
                   cutoff = maxDist,
                   alpha = c(0, 45, 90, 135))

plot(varioCloud)
```

---
class: inverse, center, middle

# Empirical variogram

<html><div style='float:left'></div><hr color='#EB811B' size=1px width=720px></html> 

---
# Definition

.content-box-green[.small[An **empirical variogram** is derived by defining bins into a cloud variogram]]


## Mathematical definition

The empirical variogram is constructed based on the following equation

$$\gamma(\mathbf{h}\pm\delta)=\frac{1}{2n_{\mathbf{h}\pm\delta}}\sum_{(i,j)}^{n_{\mathbf{h}\pm\delta}}\left(Z(\mathbf{s}_i) - Z(\mathbf{s}_j)\right)^2$$

where
- $Z(\mathbf{s_i})$ : Value of variable sampled at sample i
- $Z(\mathbf{s_j})$ : Value of variable sampled at sample j
- $\mathbf{h}\pm \delta$ : bin of size $2\delta$ at distance $\mathbf{h}$
- $n_{\mathbf{h}\pm\delta}$ : Number of samples within the bin

---
# .small[Visualization of the empirical variogram]

```{r,echo = FALSE, fig.height=5, fig.width=12, eval=TRUE}
varioCloud <- variogram(Value.Valeur ~ 1,
                   data = tpSP,
                   cutoff = 3500,
                   cloud= TRUE)

bound <- seq(0,3500, by = 250)
varioEmp <- variogram(Value.Valeur ~ 1,
                   data = tpSP,
                   cutoff = 3500,
                   boundaries = bound)

par(mar = c(5,6.5,0.5,0.5))
plot(varioCloud$dist, varioCloud$gamma,
     xlab = "Distance (m)",
     ylab = "",
     cex.lab = 2, las = 1)
mtext(text = "Variance",side = 2, cex = 2, line = 4)

bin <- c(0,((varioEmp$dist[-1] - varioEmp$dist[-15])/2 + varioEmp$dist[-15]), 3500)

abline(v = bin, col = "blue", lwd = 5)

segments(x0 = bin[-16],
         x1 = bin[-1],
         y0 = varioEmp$gamma,
         y1 = varioEmp$gamma,
         col = "orange",
         lwd = 5)
```
## Guidelines to contruct an empirical variogram
.small[
- More bins at small distances
- There should be enough values in each bin
- Defining the *right* variogram is problem specific
]


---
# Building an empirical variogram

**Total Phosphorus in sediment in the Harbour of Hamilton (Ontario)**

```{r, echo = FALSE, message=FALSE, out.height="70%", out.width="100%"}
library(mapview)
mapview(tpSP, zcol="Value.Valeur")
```

---

# Building an empirical variogram

## Step 1 - Study spatial autocorrelation

### Lagged scatter plot (take 1)

Lagged scatter plot draw point pairs at a specific separation distances. 

---
# Building an empirical variogram

```{r, echo = FALSE, fig.align="center", fig.width=12}
hscat(Value.Valeur ~ 1,
      data = tpSP,
      breaks = seq(0,maxDist, by = 500))
```

.small[There seems to be some structure among samples at distances between 0 and 1000 m.]

---
# Building an empirical variogram

## Step 1 - Study spatial autocorrelation

### Lagged scatter plot (take 2)

Lets look at finer bins within the first 2000 m (just to be on the safe side)

---
# Building an empirical variogram

```{r, echo = FALSE, fig.align="center", fig.width=12}
hscat(Value.Valeur ~ 1,
      data = tpSP,
      breaks = seq(0,2000, by = 100))
```

This results confirms that there is some autocorrelation structure within 1000 m.  

---

# Building an empirical variogram

## Step 2 - Cloud variogram 

Construct a cloud variogram with a maximum distance of 1500 m (again just to be on the safe side).

```{r, echo = FALSE, fig.align="center", fig.width=12, fig.height=5}
varioCloud <- variogram(Value.Valeur ~ 1,
                   data = tpSP,
                   cloud= TRUE,
                   cutoff = 1500)

par(mar = c(5,6.5,0.5,0.5))
plot(varioCloud$dist, varioCloud$gamma,
     xlab = "Distance (m)",
     ylab = "",
     cex.lab = 2, las = 1)
mtext(text = "Variance",side = 2, cex = 2, line = 4)
```

---

# Building an empirical variogram

## Step 3 - Check for outliers

```{r, eval=FALSE}
outliers <- plot(varioCloud, digitize = TRUE)
```

```{r echo=FALSE, out.width="100%"}
knitr::include_graphics("assets/img/Outlier.png")
```

---

# Building an empirical variogram

## Step 3 - Check for outliers

```{r, eval=FALSE}
outliers
```

```{r, echo = FALSE}
outliers <- data.frame(head = c(4, 5), tail = c(6, 6))
outliers
```

---

# Building an empirical variogram

## Step 3 - Check for outliers

```{r echo=FALSE, out.width="70%", fig.align='center'}
knitr::include_graphics("assets/img/OutlierPlot.png")
```
See something ? Look very carefully...

---

# Building an empirical variogram 

## Step 3 - Check for outliers

.tiny[
```{r}
tpSP@data[4:6,]
```
]

---

# Building an empirical variogram

## Step 4 - Remove outlier

```{r}
tpSPClean <- tpSP[-6,]
```

---
# Building an empirical variogram

## Step 5 - Redraw the cloud variogram


```{r, echo = TRUE, eval = FALSE}
varioCloud <- variogram(Value.Valeur ~ 1, data = tpSPClean,
                   cloud= TRUE,cutoff = 1500)

plot(varioCloud)
```

```{r, echo = FALSE, fig.align="center", fig.width=12, fig.height=5}
varioCloud <- variogram(Value.Valeur ~ 1,
                   data = tpSPClean,
                   cloud= TRUE,
                   cutoff = 1500)

par(mar = c(5,6.5,0.5,0.5))
plot(varioCloud$dist, varioCloud$gamma,
     xlab = "Distance (m)",
     ylab = "",
     cex.lab = 2, las = 1)
mtext(text = "Variance",side = 2, cex = 2, line = 4)
```

---

# Building an empirical variogram

## Step 6 - Define the bins

Recall that :
- More bins at small distances
- There should be enough values in each bin

```{r,echo = TRUE, fig.height=5, fig.width=12, eval=TRUE}
# Define bin limits
binLimit <- c(seq(0,1000,by = 100),
              seq(1200,1500, by = 200))

# Construct variogram
varioEmpGood <- variogram(Value.Valeur ~ 1,
                          data = tpSPClean,
                          cutoff = 1500,
                          boundaries = binLimit)
```

---

# Building an empirical variogram

## Step 6 - Define the bins

```{r,echo = TRUE, eval=TRUE, fig.align='center', fig.width=12, fig.height=5}
plot(varioEmpGood, cex = 2, pch = 19)
```

---

# Building an empirical variogram

## Step 6 - Define the bins

```{r,echo = TRUE, eval=TRUE}
head(varioEmpGood)
```

---
class: inverse, center, middle

# Model variogram

<html><div style='float:left'></div><hr color='#EB811B' size=1px width=720px></html> 

---

# Model variogram

The model variogram fits the empirical variogram.

Variogram (empirical and model alike) have a typical structure, to which some terminology is typically used.

```{r echo=FALSE, out.width="90%"}
knitr::include_graphics("https://aegis4048.github.io/jupyter_images/basic_variogram.png")
```


---

# Type of model variogram

There exist many types of model variograms. 

In the `gstat` package, 17 different types of model variograms have been implemented. 

.pull-left[
- `Nug` : nugget
- `Exp` : exponential
- `Sph` : spherical
- `Gau` : gaussian
- `Exclass` : Exponential class
- `Mat` : Matérn
- `Ste` : Stein
- `Cir` : circular
- `Lin` : linear
]
.pull-right[
- `Bes` : bessel
- `Pen` : pentaspherical
- `Per` : periodic
- `Hol` : hole
- `Log` : logarithmic
- `Pow` : power
- `Spl` : spline
- `Leg` : Legendre
- `Err` : Measurement error
- `Int` : Intercept
]
---

# Type of model variogram


```{r, echo = FALSE, fig.align="center", fig.width=12}
show.vgms()
```

---
# The Spherical model

```{r, echo = FALSE, message=FALSE, warning=FALSE, fig.height=3.5, fig.width=12, fig.align="center"}
library(gstat)
res <- show.vgms(max = 15, range = c(5, 10), plot = FALSE, models = "Sph")
par(mfrow = c(1,2), mar = c(1,1,1,1), oma = c(3,3,0,0))
plot(res[1:50,2:1], 
     type = "l", 
     lwd = 3,
     col = "blue",
     xaxt = "n",
     yaxt = "n")
legend("bottomright",
       legend = "Range = 5",
       cex = 2)

plot(res[51:100,2:1], 
     type = "l", 
     lwd = 3,
     col = "blue",
     xaxt = "n",
     yaxt = "n")
legend("bottomright",
       legend = "Range = 10",
       cex = 2)
mtext("Distance", side = 1, cex = 2, outer = TRUE)
mtext("Variance", side = 2, cex = 2, outer = TRUE)
```

.small[
$$\gamma(\boldsymbol{h}) = \left\{\begin{align}
\sigma^2_0 + \sigma^2_c\left(\frac{3\boldsymbol{h}}{2\nu}-\frac{1\boldsymbol{h^3}}{2\nu^3}\right), &\qquad 0 < \boldsymbol{h} \le \nu\\
\sigma^2_0 + \sigma^2_c, &\qquad \boldsymbol{h} \ge \nu\\
\end{align}\right.$$

- $\boldsymbol{h}$ is the distance between two samples
- $\sigma^2_0 + \sigma^2_c$ is the variance (sill)
- $\sigma^2_0$ is the nugget effect
- $\nu$ is the effective range

**Note** : When $\sigma^2_0 = 1$ and $\sigma^2_c = 1$ this model is called the *Standard Spherical Model*.
]

---
# The Exponential model

```{r, echo = FALSE, message=FALSE, warning=FALSE, fig.height=3.5, fig.width=12, fig.align="center"}
library(gstat)
res <- show.vgms(max = 15, range = c(2, 5), plot = FALSE, models = "Exp")
par(mfrow = c(1,2), mar = c(1,1,1,1), oma = c(3,3,0,0))
plot(res[1:50,2:1], 
     type = "l", 
     lwd = 3,
     col = "blue",
     xaxt = "n",
     yaxt = "n")
legend("bottomright",
       legend = "Range = 2",
       cex = 2)

plot(res[51:100,2:1], 
     type = "l", 
     lwd = 3,
     col = "blue",
     xaxt = "n",
     yaxt = "n")
legend("bottomright",
       legend = "Range = 5",
       cex = 2)
mtext("Distance", side = 1, cex = 2, outer = TRUE)
mtext("Variance", side = 2, cex = 2, outer = TRUE)
```

$$\gamma(\boldsymbol{h}) = \sigma^2_0 + \sigma^2_c\left(1 - e^{-\boldsymbol{h}/\nu}\right)$$

- $\boldsymbol{h}$ is the distance between two samples
- $\sigma^2_0 + \sigma^2_c$ is the variance (sill)
- $\sigma^2_0$ is the nugget effect
- $\nu$ is the effective range

---
# The Matérn model

```{r, echo = FALSE, message=FALSE, warning=FALSE, fig.height=3.5, fig.width=12, fig.align="center"}
library(gstat)
res <- show.vgms(kappa.range = c(5, 10),
          max = 15, plot = FALSE, models = "Mat")
par(mfrow = c(1,2), mar = c(1,1,1,1), oma = c(3,3,3,0))
plot(res[1:50,2:1], 
     type = "l", 
     lwd = 3,
     col = "blue",
     xaxt = "n",
     yaxt = "n")
legend("bottomright",
       legend = expression(paste(kappa,"= 5")),
       cex = 2)

plot(res[51:100,2:1], 
     type = "l", 
     lwd = 3,
     col = "blue",
     xaxt = "n",
     yaxt = "n")
legend("bottomright",
       legend = expression(paste(kappa,"= 10")),
       cex = 2)
mtext("Distance", side = 1, cex = 2, outer = TRUE)
mtext("Variance", side = 2, cex = 2, outer = TRUE)
mtext("Sill = 1 - Range = 1", side = 3, cex = 2, outer = TRUE)
```

.small[
$$\gamma(\boldsymbol{h}) = \frac{\sigma^2}{2^{\nu-1}\Gamma(\nu)}\left(\kappa \boldsymbol{h}\right)^\nu K_\nu\left(\kappa \boldsymbol{h}\right)$$
]

where
- $\boldsymbol{h}$ is the distance between two samples
- $\sigma^2$ is the variance (sill)
- $\nu$ is the range
- $\kappa$ is scaling parameter (always $> 0$)
- $K_\nu$ is a Bessel function of the second kind of order $\nu$
---

# Choosing the right model variogram

Choosing the right model variogram depends on the problem at hand.

However, there are a few important aspects worth knowing

## General aspects
- The variogram chosen should relate to the question you are asking
- This is not only curve fitting

## Aspects specific to a model variogram

- Some doubts have been raised about the **hole** model variogram
- The **spline** model variogram seems to need exceeding large range values to fit an empirical variogram properly

---

# Fitting a model variogram

There exist a few ways to fit a model variogram to an empirical variogram.

## Visually

By trying to visually pass the best possible curve to the empirical variogram.

This approach is implemented in the package `geoR` in the function `eyefit`.

.Large[.red[**Not recommended**]]

---

# Fitting a model variogram

There exist a few ways to fit a model variogram to an empirical variogram. In the `fit.variogram` function of the `gstat` package.

## Weighing the importance of the bin
Using as weight
- The number of points per bin (`fit.method = 1`)
$$n_{\mathbf{h}_j}$$
- The number of points per bin divided by the variance (`fit.method = 2`)
$$\frac{n_{\mathbf{h}_j}}{\gamma(\boldsymbol h_j)^2}$$

---

# Fitting a model variogram

There exist a few ways to fit a model variogram to an empirical variogram. In the `fit.variogram` function of the `gstat` package.

## Weighing the importance of the bin
Using as weight
- The number of points per bin divided by the squared bin size (`fit.method=7`)
$$\frac{n_{\mathbf{h}_j}}{\boldsymbol h_j^2}$$

This is the default option in `fit.variogram`. 

In practice, it is a technique that has been shown to work well, but is not supported by theory.

---

# Fitting a model variogram

There exist a few ways to fit a model variogram to an empirical variogram. In the `fit.variogram` function of the `gstat` package.

## Using ordinary least squares (OLS)
The sums of squares between the model and the data is minimized (`fit.method=6`)

$$\sum\left(Z(\mathbf{s})-\widehat{Z}(\mathbf{s})\right)^2$$

---

# Fitting a model variogram

## Using restricted maximum likelihood (REML)

The `fit.variogram.reml` function  of the `gstat` package uses a restricted maximum likelihood (REML) approach to fit the model variogram to the empirical variogram. 

This is approach is rather slow and it is not recommended if there are more than 100 samples. 

This approach relies on all distances (pairs of points;  cloud variogram) to fit the model variogram.

---

# Choosing the right fitting approach

The short answer is : 

.Large["It depends !"]

.small[
Visual fitting: Use **only** to get some starting values for other model fitting approaches. 

`fit.method = 1` : If you want to place more emphasis on the number of points in bins.

`fit.method = 2` : If you want to account for the variation of the data in bins.

`fit.method = 6` : If you **do not** want to account for the size of the bins. This approach only fits the model to the points (That's it!) This may be interesting to use if the bins all have the same number of points.

`fit.method = 7` :  If you want to account for the size (in distance) of bins.

`fit.variogram.reml` : Theoretically, this is often the best approach, but because it is slow, it becomes useless to use it for moderate to large datasets (more 100 samples). 
]

---

# Fitting a model variogram in practice

**Total Phosphorus in sediment in the Harbour of Hamilton (Ontario)**

```{r, echo = FALSE, message=FALSE, out.height="55%", out.width="100%"}
library(mapview)
mapview(tpSP, zcol="Value.Valeur")
```

## Step 1 - Let's think of what we are measuring
- Do we know how it should vary in space (from the litterature) ?
- Are there some particularities of the sampling we need to account for ?
- ...

---
# Fitting a model variogram in practice

## Step 2 - Choosing the right model variogram

Let's look at the empirical variogram
```{r,echo = FALSE, eval=TRUE, fig.align='center', fig.width=12, fig.height=4}
plot(varioEmpGood, cex = 2, pch = 19)
```

We also need to think about:
- The property of the variable we are modelling
- The reasons **why** we want to model it

For this example, we will use the **exponential** model variogram.

---
# Fitting a model variogram in practice

## Step 3 - Fitting the model variogram

Always keep in mind : 
- The property of the variable we are modelling
- The reasons **why** we want to model it

Let's use REML

```{r, eval = TRUE}
tpDF <- data.frame(x = coordinates(tpSPClean)[,1],
                   y = coordinates(tpSPClean)[,2],
                   tpSPClean@data)

modelIni <-  vgm(psill = 4e5, model = "Exp",
                 range = 800, nugget = 50000)

modelVario <- fit.variogram.reml(Value.Valeur ~ 1,
                                 ~ x + y, 
                                 data = tpDF,
                                 model =modelIni)
```

---
# Fitting a model variogram in practice

## Step 4 - Visualization

```{r, echo = FALSE, fig.align='center', fig.height=5, fig.width=12}
plot(varioCloud, model = modelVario, lwd = 3)
```

---
class: inverse, center, middle

# Spatiotemporal variogram

<html><div style='float:left'></div><hr color='#EB811B' size=3px width=720px></html> 
<html><div style='float:left'></div><hr color='#EB811B' size=3px width=720px></html> 

---
class: inverse, center, middle

# Empirical variogram

<html><div style='float:left'></div><hr color='#EB811B' size=1px width=720px></html> 

---
# Spatiotemporal empirical variogram

Spatiotemporal empirical variogram are technically exactly the same as their spatial counterpart. The only difference is that time needs to be accounted. 

As such, time and space needs to be bin following the same rules as for spatial empirical variograms.

```{r echo=FALSE, out.width="50%", fig.align='center'}
knitr::include_graphics("assets/img/STempiricalVario.png")
```

---
class: inverse, center, middle

# Model variogram

<html><div style='float:left'></div><hr color='#EB811B' size=1px width=720px></html> 

---
# Spatiotemporal model variogram

As for the spatial model variogram, we need to decide the type of model variogram to use. 

In addition, we need to decide how to link space and time. This is done througth the `vgmST` function in `gstat`

In short, space and time can be modelled seperately or jointly and weights can be given to the relationship.

---
# Spatiotemporal model variogram

```{r echo=FALSE, out.width="60%", fig.align='center'}
knitr::include_graphics("assets/img/STmodelVario.png")
```


---

---

---

---


---

# Checking for temporal dependence
.small[
The *Durbin-Watson statistics* can be defined as follow:

$$d=\frac{\sum_{t=2}^T\left(\widehat{\varepsilon}_t - \widehat{\varepsilon}_{t-1}\right)^2}{\sum_{t=1}^T\widehat{\varepsilon}_t^2}$$
where $\widehat{\varepsilon}_t = Z_t - \widehat{Z}_t$, which represents the  model's residuals.

In words, $d$, the Durbin-Watson test measures the degree of autocorrelations in a time serie.
]

## Properties of the Durbin-Watson test
.small[
- If $d$ is small (close to 0), there is evidence of positive autocorrelation (serial dependence) in the time series
  - A general "rule of thumb" is that a value smaller than 1 represent strong positive serial dependence
- As $d$ gets larger, it suggest no positive serial dependence.
- The value of $d$ ranges theoretically from 0 to 4
]

---

---


---
---

# Checking for space-time dependence

.footnotesize[
The *space-time index* (STI) is a type of Moran's $I$ statistics for spatiotemporal data. It can be defined as follow:

$$\text{STI}=\frac{m(T-1)\sum_{t=2}^T\sum_{i=1}^m\sum_{j=1}^mw_{i,j,t-1}\left(Z_i(\mathbf{s}_i,t) - \overline{Z}(\mathbf{s},t)\right)\left(Z_j(\mathbf{s}_i,t) - \overline{Z}(\mathbf{s},t)\right)}{\left(\sum_{t=2}^T\sum_{i=1}^m\sum_{j=1}^mw_{i,j,t-1}\right)\left(\sum_{t=1}^T\sum_{i=1}^m\left(Z_i(\mathbf{s}_i,t) - \overline{Z}(\mathbf{s},t)\right)^2\right)}$$

where 
- $Z_i(\mathbf{s}_i,t)$ is the spatiotemporal data (it could also be the residuals)
- $\overline{Z}(\mathbf{s},t)$ is the mean of the data (or of the residuals) across the full data
- $w_{i,j,t-1}$ is the strength of the relation between samples $i$ and $j$ at time $t-1$
]

## Properties of the space-time index (STI)
.footnotesize[
It has similar properties as Moran's $I$

- If $STI$ is positive, it suggest there is positive spatial autocorrelation
- If $STI$ is negative, it suggest there is negative spatial autocorrelation
- As $STI$ is close to 0, it suggest there no spatial autocorrelation
- The value of $STI$ ranges theoretically from -1 to 1
]

